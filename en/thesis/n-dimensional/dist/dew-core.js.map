{
  "version": 3,
  "sources": ["../src/index.ts", "../src/computeSlope.ts", "../src/getRadialCoordinates.ts", "../src/getRandomNumber.ts", "../src/shuffleArray.ts", "../src/sortByRadialDistance.ts", "../src/computeUniDimensionalDistance.ts", "../src/computeMultiDimensionalDistance.ts", "../src/sortByVectorDistance.ts", "../src/sortByRandomOrder.ts", "../src/sortAffectiveSpace.ts", "../src/subsetFeelings.ts", "../src/simulateVectorAffectiveSpace.ts"],
  "sourcesContent": ["export { computeSlope } from \"./computeSlope\";\r\nexport { getRadialCoordinates } from \"./getRadialCoordinates\";\r\nexport { getRandomNumber } from \"./getRandomNumber\";\r\nexport { shuffleArray } from \"./shuffleArray\";\r\nexport { sortAffectiveSpace } from \"./sortAffectiveSpace\";\r\nexport { sortByRadialDistance } from \"./sortByRadialDistance\";\r\nexport { sortByRandomOrder } from \"./sortByRandomOrder\";\r\nexport { sortByVectorDistance } from \"./sortByVectorDistance\";\r\nexport { subsetFeelings } from \"./subsetFeelings\";\r\nexport { simulateVectorAffectiveSpace } from \"./simulateVectorAffectiveSpace\";\r\nexport { computeUniDimensionalDistance } from \"./computeUniDimensionalDistance\";\r\nexport { computeMultiDimensionalDistance } from \"./computeMultiDimensionalDistance\";", "export const computeSlope = function (x: number, y: number) {\n  let slope = Math.PI / 2 - Math.atan(y / x);\n  if (x > 0 && y > 0) {\n    slope = slope - 0.5 * Math.PI;\n  } else if (x < 0 && y < 0) {\n    slope = slope + 0.5 * Math.PI;\n  } else if (x > 0 && y < 0) {\n    slope = slope - 0.5 * Math.PI;\n  } else if (x < 0 && y > 0) {\n    slope = slope + 0.5 * Math.PI;\n  } else {\n    slope = 0;\n  }\n  slope = (slope * 180) / Math.PI + 90;\n  return slope;\n};\n", "import { AffectiveSpace } from \"./affectiveSpace.interface\";\nimport { Feeling } from \"./feeling.interface\";\n\nexport const getRadialCoordinates = function (\n  affectiveSpace: AffectiveSpace,\n  center: number,\n  radius: number\n): Feeling[] {\n  function getRadialX(angle: number): number {\n    let x = center + radius * Math.cos((angle * Math.PI) / 180);\n    return x;\n  }\n  function getRadialY(angle: number): number {\n    let y = center + radius * Math.sin((angle * Math.PI) / 180);\n    return y;\n  }\n\n  let copyOfAffectiveSpace = JSON.parse(JSON.stringify(affectiveSpace));\n\n  return copyOfAffectiveSpace.feelings.map(function (feeling: Feeling) {\n    let currentAngle = feeling.angle as number;\n    feeling.coordinates = [];\n    feeling.coordinates[0] = getRadialX(currentAngle);\n    feeling.coordinates[1] = getRadialY(currentAngle);\n    return feeling;\n  });\n};\n", "export const getRandomNumber = function (min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min)) + min;\n};\n", "export const shuffleArray = function (array: Array<any>): Array<any> {\n  let currentIndex = array.length;\n  let temporaryValue, randomIndex;\n\n  while (currentIndex !== 0) {\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n};\n", "import { computeSlope } from \"./computeSlope\";\nimport { Feeling } from \"./feeling.interface\";\n\nexport const sortByRadialDistance = function (\n  feelings: Array<Feeling>,\n  x: number,\n  y: number\n): Array<Feeling> {\n  let currentSlope = computeSlope(x, y);\n\n  function orderByAngle(firstFeeling: Feeling, secondFeeling: Feeling) {\n    let firstFeelingAngle = firstFeeling.angle as number;\n    let secondFeelingAngle = secondFeeling.angle as number;\n    return (\n      Math.abs(firstFeelingAngle - currentSlope) -\n      Math.abs(secondFeelingAngle - currentSlope)\n    );\n  }\n\n  feelings.sort(orderByAngle);\n\n  return feelings;\n};\n", "export const computeUniDimensionalDistance = function (firstArray: number[], secondArray: number[]): number {\r\n    return Math.abs(firstArray[0] - secondArray[0]);\r\n}", "export const computeMultiDimensionalDistance = function (firstArray: number[], secondArray: number[]): number {\r\n    // First feeling\r\n    let multiDimensionalDistance: number = 0;\r\n    for (let i = 0; i < firstArray.length; i++) {\r\n        multiDimensionalDistance += Math.pow((firstArray[i] - secondArray[i]), 2)\r\n    }\r\n    multiDimensionalDistance = Math.sqrt(multiDimensionalDistance);\r\n\r\n    return multiDimensionalDistance;\r\n}", "import { Feeling } from \"./feeling.interface\";\nimport { computeUniDimensionalDistance } from \"./computeUniDimensionalDistance\";\nimport { computeMultiDimensionalDistance } from \"./computeMultiDimensionalDistance\";\n\nexport const sortByVectorDistance = function (\n  feelings: Array<Feeling>,\n  appraisals: number[]\n): Array<Feeling> {\n\n  // Sort by One Dimension\n  function sortByOneDimension(firstFeeling: Feeling, secondFeeling: Feeling) {\n    //Absolue delta first feeling\n    let deltaFirstFeeling = computeUniDimensionalDistance(firstFeeling.coordinates, appraisals);\n    //Absolute delta second feeling\n    let deltaSecondFeeling = computeUniDimensionalDistance(secondFeeling.coordinates, appraisals);\n\n    if (deltaFirstFeeling > deltaSecondFeeling) {\n      return 1;\n    } else if (deltaFirstFeeling < deltaSecondFeeling) {\n      return -1;\n    } else {\n      return 0;\n    }\n\n  }\n\n  // Sort by Multiple Dimensions\n  function sortByMultiDimensions(firstFeeling: Feeling, secondFeeling: Feeling) {\n\n    // First feeling\n    let distanceFirstFeeling: number = computeMultiDimensionalDistance(appraisals, firstFeeling.coordinates);\n\n    // Second feeling\n    let distanceSecondFeeling: number = computeMultiDimensionalDistance(appraisals, secondFeeling.coordinates);\n\n    if (distanceFirstFeeling > distanceSecondFeeling) {\n      return 1;\n    } else if (distanceFirstFeeling < distanceSecondFeeling) {\n      return -1;\n    } else {\n      return 0;\n    }\n  }\n\n  //Check number of appraisals\n  let numAppraisals = appraisals.length;\n\n  if (numAppraisals === 1) {\n    feelings.sort(sortByOneDimension);\n  } else if (numAppraisals > 1) {\n    feelings.sort(sortByMultiDimensions)\n  } else {\n    console.log(\"The number of appraisals is not valid\");\n  }\n\n  return feelings;\n};\n", "import { shuffleArray } from \"./shuffleArray\";\nimport { Feeling } from \"./feeling.interface\";\n\nexport const sortByRandomOrder = function (feelings: Array<Feeling>): Array<Feeling> {\n  return shuffleArray(feelings);\n};\n", "import { getRandomNumber } from \"./getRandomNumber\";\nimport { sortByRadialDistance } from \"./sortByRadialDistance\";\nimport { sortByVectorDistance } from \"./sortByVectorDistance\";\nimport { sortByRandomOrder } from \"./sortByRandomOrder\";\nimport { AffectiveSpace } from \"./affectiveSpace.interface\";\nimport { Feeling } from \"./feeling.interface\";\n\nexport const sortAffectiveSpace = function (\n  space: AffectiveSpace,\n  appraisals: number[]\n): Array<Feeling> {\n  //Create a copy of the feelings array to sort\n  let copyOfAffectiveSpace: AffectiveSpace = JSON.parse(JSON.stringify(space));\n  let copyOfFeelings: Feeling[] = copyOfAffectiveSpace.feelings;\n\n  let sortedFeelings: Array<Feeling> = [];\n\n  //Determine the function to call to sort the feelings\n  if (space.algorithmType.toLocaleLowerCase() === \"radial\") {\n    //Check if both x and y are 0. If they are, provide random number instead\n    if (appraisals[0] === 0 && appraisals[1] === 0) {\n      appraisals[0] = getRandomNumber(-100, 100);\n      appraisals[1] = getRandomNumber(-100, 100);\n    }\n\n    sortedFeelings = sortByRadialDistance(copyOfFeelings, appraisals[0], appraisals[1]);\n  } else if (space.algorithmType.toLocaleLowerCase() === \"vector\") {\n    sortedFeelings = sortByVectorDistance(copyOfFeelings, appraisals);\n  } else if (space.algorithmType.toLocaleLowerCase() === \"random\") {\n    sortedFeelings = sortByRandomOrder(copyOfFeelings);\n  } else {\n    console.log(\"Provide a valid algorithm type.\");\n  }\n\n  return sortedFeelings;\n};\n", "import { Feeling } from \"./feeling.interface\";\n\nexport const subsetFeelings = function (\n  feelings: Array<Feeling>,\n  cardinality: number\n): Array<Feeling> {\n  let subset = feelings.slice(0, cardinality);\n  return subset;\n};\n", "import { AffectiveSpace } from \"./affectiveSpace.interface\";\r\nimport { Feeling } from \"./feeling.interface\";\r\nimport { getRandomNumber } from \"./getRandomNumber\";\r\n\r\nexport function simulateVectorAffectiveSpace(numEmotions: number, numAppraisals: number): AffectiveSpace {\r\n    let feelings: Array<Feeling> = [];\r\n    for (let i = 0; i < numEmotions; i++) {\r\n        let randomCoordinates = [];\r\n        for (let j = 0; j < numAppraisals; j++) {\r\n            randomCoordinates.push(getRandomNumber(-100, 100));\r\n        }\r\n        feelings.push({\r\n            label: \"Feeling #\".concat(String(i + 1)),\r\n            coordinates: randomCoordinates,\r\n        });\r\n    }\r\n\r\n    return {\r\n        algorithmType: \"vector\",\r\n        feelings: feelings\r\n    };\r\n}"],
  "mappings": "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",
  "names": []
}
