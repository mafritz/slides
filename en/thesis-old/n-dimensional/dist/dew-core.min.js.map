{
  "version": 3,
  "sources": ["../src/index.ts", "../src/computeSlope.ts", "../src/getRadialCoordinates.ts", "../src/getRandomNumber.ts", "../src/shuffleArray.ts", "../src/sortByRadialDistance.ts", "../src/computeUniDimensionalDistance.ts", "../src/computeMultiDimensionalDistance.ts", "../src/sortByVectorDistance.ts", "../src/sortByRandomOrder.ts", "../src/sortAffectiveSpace.ts", "../src/subsetFeelings.ts", "../src/simulateVectorAffectiveSpace.ts"],
  "sourcesContent": ["export { computeSlope } from \"./computeSlope\";\r\nexport { getRadialCoordinates } from \"./getRadialCoordinates\";\r\nexport { getRandomNumber } from \"./getRandomNumber\";\r\nexport { shuffleArray } from \"./shuffleArray\";\r\nexport { sortAffectiveSpace } from \"./sortAffectiveSpace\";\r\nexport { sortByRadialDistance } from \"./sortByRadialDistance\";\r\nexport { sortByRandomOrder } from \"./sortByRandomOrder\";\r\nexport { sortByVectorDistance } from \"./sortByVectorDistance\";\r\nexport { subsetFeelings } from \"./subsetFeelings\";\r\nexport { simulateVectorAffectiveSpace } from \"./simulateVectorAffectiveSpace\";\r\nexport { computeUniDimensionalDistance } from \"./computeUniDimensionalDistance\";\r\nexport { computeMultiDimensionalDistance } from \"./computeMultiDimensionalDistance\";", "export const computeSlope = function (x: number, y: number) {\n  let slope = Math.PI / 2 - Math.atan(y / x);\n  if (x > 0 && y > 0) {\n    slope = slope - 0.5 * Math.PI;\n  } else if (x < 0 && y < 0) {\n    slope = slope + 0.5 * Math.PI;\n  } else if (x > 0 && y < 0) {\n    slope = slope - 0.5 * Math.PI;\n  } else if (x < 0 && y > 0) {\n    slope = slope + 0.5 * Math.PI;\n  } else {\n    slope = 0;\n  }\n  slope = (slope * 180) / Math.PI + 90;\n  return slope;\n};\n", "import { AffectiveSpace } from \"./affectiveSpace.interface\";\nimport { Feeling } from \"./feeling.interface\";\n\nexport const getRadialCoordinates = function (\n  affectiveSpace: AffectiveSpace,\n  center: number,\n  radius: number\n): Feeling[] {\n  function getRadialX(angle: number): number {\n    let x = center + radius * Math.cos((angle * Math.PI) / 180);\n    return x;\n  }\n  function getRadialY(angle: number): number {\n    let y = center + radius * Math.sin((angle * Math.PI) / 180);\n    return y;\n  }\n\n  let copyOfAffectiveSpace = JSON.parse(JSON.stringify(affectiveSpace));\n\n  return copyOfAffectiveSpace.feelings.map(function (feeling: Feeling) {\n    let currentAngle = feeling.angle as number;\n    feeling.coordinates = [];\n    feeling.coordinates[0] = getRadialX(currentAngle);\n    feeling.coordinates[1] = getRadialY(currentAngle);\n    return feeling;\n  });\n};\n", "export const getRandomNumber = function (min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min)) + min;\n};\n", "export const shuffleArray = function (array: Array<any>): Array<any> {\n  let currentIndex = array.length;\n  let temporaryValue, randomIndex;\n\n  while (currentIndex !== 0) {\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n};\n", "import { computeSlope } from \"./computeSlope\";\nimport { Feeling } from \"./feeling.interface\";\n\nexport const sortByRadialDistance = function (\n  feelings: Array<Feeling>,\n  x: number,\n  y: number\n): Array<Feeling> {\n  let currentSlope = computeSlope(x, y);\n\n  function orderByAngle(firstFeeling: Feeling, secondFeeling: Feeling) {\n    let firstFeelingAngle = firstFeeling.angle as number;\n    let secondFeelingAngle = secondFeeling.angle as number;\n    return (\n      Math.abs(firstFeelingAngle - currentSlope) -\n      Math.abs(secondFeelingAngle - currentSlope)\n    );\n  }\n\n  feelings.sort(orderByAngle);\n\n  return feelings;\n};\n", "export const computeUniDimensionalDistance = function (firstArray: number[], secondArray: number[]): number {\r\n    return Math.abs(firstArray[0] - secondArray[0]);\r\n}", "export const computeMultiDimensionalDistance = function (firstArray: number[], secondArray: number[]): number {\r\n    // First feeling\r\n    let multiDimensionalDistance: number = 0;\r\n    for (let i = 0; i < firstArray.length; i++) {\r\n        multiDimensionalDistance += Math.pow((firstArray[i] - secondArray[i]), 2)\r\n    }\r\n    multiDimensionalDistance = Math.sqrt(multiDimensionalDistance);\r\n\r\n    return multiDimensionalDistance;\r\n}", "import { Feeling } from \"./feeling.interface\";\nimport { computeUniDimensionalDistance } from \"./computeUniDimensionalDistance\";\nimport { computeMultiDimensionalDistance } from \"./computeMultiDimensionalDistance\";\n\nexport const sortByVectorDistance = function (\n  feelings: Array<Feeling>,\n  appraisals: number[]\n): Array<Feeling> {\n\n  // Sort by One Dimension\n  function sortByOneDimension(firstFeeling: Feeling, secondFeeling: Feeling) {\n    //Absolue delta first feeling\n    let deltaFirstFeeling = computeUniDimensionalDistance(firstFeeling.coordinates, appraisals);\n    //Absolute delta second feeling\n    let deltaSecondFeeling = computeUniDimensionalDistance(secondFeeling.coordinates, appraisals);\n\n    if (deltaFirstFeeling > deltaSecondFeeling) {\n      return 1;\n    } else if (deltaFirstFeeling < deltaSecondFeeling) {\n      return -1;\n    } else {\n      return 0;\n    }\n\n  }\n\n  // Sort by Multiple Dimensions\n  function sortByMultiDimensions(firstFeeling: Feeling, secondFeeling: Feeling) {\n\n    // First feeling\n    let distanceFirstFeeling: number = computeMultiDimensionalDistance(appraisals, firstFeeling.coordinates);\n\n    // Second feeling\n    let distanceSecondFeeling: number = computeMultiDimensionalDistance(appraisals, secondFeeling.coordinates);\n\n    if (distanceFirstFeeling > distanceSecondFeeling) {\n      return 1;\n    } else if (distanceFirstFeeling < distanceSecondFeeling) {\n      return -1;\n    } else {\n      return 0;\n    }\n  }\n\n  //Check number of appraisals\n  let numAppraisals = appraisals.length;\n\n  if (numAppraisals === 1) {\n    feelings.sort(sortByOneDimension);\n  } else if (numAppraisals > 1) {\n    feelings.sort(sortByMultiDimensions)\n  } else {\n    console.log(\"The number of appraisals is not valid\");\n  }\n\n  return feelings;\n};\n", "import { shuffleArray } from \"./shuffleArray\";\nimport { Feeling } from \"./feeling.interface\";\n\nexport const sortByRandomOrder = function (feelings: Array<Feeling>): Array<Feeling> {\n  return shuffleArray(feelings);\n};\n", "import { getRandomNumber } from \"./getRandomNumber\";\nimport { sortByRadialDistance } from \"./sortByRadialDistance\";\nimport { sortByVectorDistance } from \"./sortByVectorDistance\";\nimport { sortByRandomOrder } from \"./sortByRandomOrder\";\nimport { AffectiveSpace } from \"./affectiveSpace.interface\";\nimport { Feeling } from \"./feeling.interface\";\n\nexport const sortAffectiveSpace = function (\n  space: AffectiveSpace,\n  appraisals: number[]\n): Array<Feeling> {\n  //Create a copy of the feelings array to sort\n  let copyOfAffectiveSpace: AffectiveSpace = JSON.parse(JSON.stringify(space));\n  let copyOfFeelings: Feeling[] = copyOfAffectiveSpace.feelings;\n\n  let sortedFeelings: Array<Feeling> = [];\n\n  //Determine the function to call to sort the feelings\n  if (space.algorithmType.toLocaleLowerCase() === \"radial\") {\n    //Check if both x and y are 0. If they are, provide random number instead\n    if (appraisals[0] === 0 && appraisals[1] === 0) {\n      appraisals[0] = getRandomNumber(-100, 100);\n      appraisals[1] = getRandomNumber(-100, 100);\n    }\n\n    sortedFeelings = sortByRadialDistance(copyOfFeelings, appraisals[0], appraisals[1]);\n  } else if (space.algorithmType.toLocaleLowerCase() === \"vector\") {\n    sortedFeelings = sortByVectorDistance(copyOfFeelings, appraisals);\n  } else if (space.algorithmType.toLocaleLowerCase() === \"random\") {\n    sortedFeelings = sortByRandomOrder(copyOfFeelings);\n  } else {\n    console.log(\"Provide a valid algorithm type.\");\n  }\n\n  return sortedFeelings;\n};\n", "import { Feeling } from \"./feeling.interface\";\n\nexport const subsetFeelings = function (\n  feelings: Array<Feeling>,\n  cardinality: number\n): Array<Feeling> {\n  let subset = feelings.slice(0, cardinality);\n  return subset;\n};\n", "import { AffectiveSpace } from \"./affectiveSpace.interface\";\r\nimport { Feeling } from \"./feeling.interface\";\r\nimport { getRandomNumber } from \"./getRandomNumber\";\r\n\r\nexport function simulateVectorAffectiveSpace(numEmotions: number, numAppraisals: number): AffectiveSpace {\r\n    let feelings: Array<Feeling> = [];\r\n    for (let i = 0; i < numEmotions; i++) {\r\n        let randomCoordinates = [];\r\n        for (let j = 0; j < numAppraisals; j++) {\r\n            randomCoordinates.push(getRandomNumber(-100, 100));\r\n        }\r\n        feelings.push({\r\n            label: \"Feeling #\".concat(String(i + 1)),\r\n            coordinates: randomCoordinates,\r\n        });\r\n    }\r\n\r\n    return {\r\n        algorithmType: \"vector\",\r\n        feelings: feelings\r\n    };\r\n}"],
  "mappings": "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",
  "names": []
}
